/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    isProgramError,
    type Address,
    type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,
    type SolanaError,
} from '@solana/kit';
import { TESTUDO_BONDS_PROGRAM_ADDRESS } from '../programs';

/** DeserializationError: Error deserializing an account */
export const TESTUDO_BONDS_ERROR__DESERIALIZATION_ERROR = 0x0; // 0
/** SerializationError: Error serializing an account */
export const TESTUDO_BONDS_ERROR__SERIALIZATION_ERROR = 0x1; // 1
/** InvalidProgramOwner: Invalid program owner. This likely mean the provided account does not exist */
export const TESTUDO_BONDS_ERROR__INVALID_PROGRAM_OWNER = 0x2; // 2
/** InvalidPda: Invalid PDA derivation */
export const TESTUDO_BONDS_ERROR__INVALID_PDA = 0x3; // 3
/** ExpectedEmptyAccount: Expected empty account */
export const TESTUDO_BONDS_ERROR__EXPECTED_EMPTY_ACCOUNT = 0x4; // 4
/** ExpectedNonEmptyAccount: Expected non empty account */
export const TESTUDO_BONDS_ERROR__EXPECTED_NON_EMPTY_ACCOUNT = 0x5; // 5
/** ExpectedSignerAccount: Expected signer account */
export const TESTUDO_BONDS_ERROR__EXPECTED_SIGNER_ACCOUNT = 0x6; // 6
/** ExpectedWritableAccount: Expected writable account */
export const TESTUDO_BONDS_ERROR__EXPECTED_WRITABLE_ACCOUNT = 0x7; // 7
/** AccountMismatch: Account mismatch */
export const TESTUDO_BONDS_ERROR__ACCOUNT_MISMATCH = 0x8; // 8
/** InvalidAccountKey: Invalid account key */
export const TESTUDO_BONDS_ERROR__INVALID_ACCOUNT_KEY = 0x9; // 9
/** NumericalOverflow: Numerical overflow */
export const TESTUDO_BONDS_ERROR__NUMERICAL_OVERFLOW = 0xa; // 10
/** InsufficientTokens: Insufficient native tokens */
export const TESTUDO_BONDS_ERROR__INSUFFICIENT_TOKENS = 0xb; // 11
/** InvalidBondIndex: Invalid bond index */
export const TESTUDO_BONDS_ERROR__INVALID_BOND_INDEX = 0xc; // 12
/** InvalidTokenAccounts: Invalid token accounts */
export const TESTUDO_BONDS_ERROR__INVALID_TOKEN_ACCOUNTS = 0xd; // 13
/** NoRewardsToClaim: No rewards to claim */
export const TESTUDO_BONDS_ERROR__NO_REWARDS_TO_CLAIM = 0xe; // 14
/** InsufficientRewards: Insufficient rewards */
export const TESTUDO_BONDS_ERROR__INSUFFICIENT_REWARDS = 0xf; // 15
/** BondNotActive: Bond not active */
export const TESTUDO_BONDS_ERROR__BOND_NOT_ACTIVE = 0x10; // 16
/** MaxBondsReached: Max bonds reached */
export const TESTUDO_BONDS_ERROR__MAX_BONDS_REACHED = 0x11; // 17
/** BondOperationsPaused: Bond operations paused */
export const TESTUDO_BONDS_ERROR__BOND_OPERATIONS_PAUSED = 0x12; // 18
/** BondIsActive: Bond is active */
export const TESTUDO_BONDS_ERROR__BOND_IS_ACTIVE = 0x13; // 19

export type TestudoBondsError =
    | typeof TESTUDO_BONDS_ERROR__ACCOUNT_MISMATCH
    | typeof TESTUDO_BONDS_ERROR__BOND_IS_ACTIVE
    | typeof TESTUDO_BONDS_ERROR__BOND_NOT_ACTIVE
    | typeof TESTUDO_BONDS_ERROR__BOND_OPERATIONS_PAUSED
    | typeof TESTUDO_BONDS_ERROR__DESERIALIZATION_ERROR
    | typeof TESTUDO_BONDS_ERROR__EXPECTED_EMPTY_ACCOUNT
    | typeof TESTUDO_BONDS_ERROR__EXPECTED_NON_EMPTY_ACCOUNT
    | typeof TESTUDO_BONDS_ERROR__EXPECTED_SIGNER_ACCOUNT
    | typeof TESTUDO_BONDS_ERROR__EXPECTED_WRITABLE_ACCOUNT
    | typeof TESTUDO_BONDS_ERROR__INSUFFICIENT_REWARDS
    | typeof TESTUDO_BONDS_ERROR__INSUFFICIENT_TOKENS
    | typeof TESTUDO_BONDS_ERROR__INVALID_ACCOUNT_KEY
    | typeof TESTUDO_BONDS_ERROR__INVALID_BOND_INDEX
    | typeof TESTUDO_BONDS_ERROR__INVALID_PDA
    | typeof TESTUDO_BONDS_ERROR__INVALID_PROGRAM_OWNER
    | typeof TESTUDO_BONDS_ERROR__INVALID_TOKEN_ACCOUNTS
    | typeof TESTUDO_BONDS_ERROR__MAX_BONDS_REACHED
    | typeof TESTUDO_BONDS_ERROR__NO_REWARDS_TO_CLAIM
    | typeof TESTUDO_BONDS_ERROR__NUMERICAL_OVERFLOW
    | typeof TESTUDO_BONDS_ERROR__SERIALIZATION_ERROR;

let testudoBondsErrorMessages: Record<TestudoBondsError, string> | undefined;
if (process.env.NODE_ENV !== 'production') {
    testudoBondsErrorMessages = {
        [TESTUDO_BONDS_ERROR__ACCOUNT_MISMATCH]: `Account mismatch`,
        [TESTUDO_BONDS_ERROR__BOND_IS_ACTIVE]: `Bond is active`,
        [TESTUDO_BONDS_ERROR__BOND_NOT_ACTIVE]: `Bond not active`,
        [TESTUDO_BONDS_ERROR__BOND_OPERATIONS_PAUSED]: `Bond operations paused`,
        [TESTUDO_BONDS_ERROR__DESERIALIZATION_ERROR]: `Error deserializing an account`,
        [TESTUDO_BONDS_ERROR__EXPECTED_EMPTY_ACCOUNT]: `Expected empty account`,
        [TESTUDO_BONDS_ERROR__EXPECTED_NON_EMPTY_ACCOUNT]: `Expected non empty account`,
        [TESTUDO_BONDS_ERROR__EXPECTED_SIGNER_ACCOUNT]: `Expected signer account`,
        [TESTUDO_BONDS_ERROR__EXPECTED_WRITABLE_ACCOUNT]: `Expected writable account`,
        [TESTUDO_BONDS_ERROR__INSUFFICIENT_REWARDS]: `Insufficient rewards`,
        [TESTUDO_BONDS_ERROR__INSUFFICIENT_TOKENS]: `Insufficient native tokens`,
        [TESTUDO_BONDS_ERROR__INVALID_ACCOUNT_KEY]: `Invalid account key`,
        [TESTUDO_BONDS_ERROR__INVALID_BOND_INDEX]: `Invalid bond index`,
        [TESTUDO_BONDS_ERROR__INVALID_PDA]: `Invalid PDA derivation`,
        [TESTUDO_BONDS_ERROR__INVALID_PROGRAM_OWNER]: `Invalid program owner. This likely mean the provided account does not exist`,
        [TESTUDO_BONDS_ERROR__INVALID_TOKEN_ACCOUNTS]: `Invalid token accounts`,
        [TESTUDO_BONDS_ERROR__MAX_BONDS_REACHED]: `Max bonds reached`,
        [TESTUDO_BONDS_ERROR__NO_REWARDS_TO_CLAIM]: `No rewards to claim`,
        [TESTUDO_BONDS_ERROR__NUMERICAL_OVERFLOW]: `Numerical overflow`,
        [TESTUDO_BONDS_ERROR__SERIALIZATION_ERROR]: `Error serializing an account`,
    };
}

export function getTestudoBondsErrorMessage(code: TestudoBondsError): string {
    if (process.env.NODE_ENV !== 'production') {
        return (testudoBondsErrorMessages as Record<TestudoBondsError, string>)[
            code
        ];
    }

    return 'Error message not available in production bundles.';
}

export function isTestudoBondsError<
    TProgramErrorCode extends TestudoBondsError,
>(
    error: unknown,
    transactionMessage: {
        instructions: Record<number, { programAddress: Address }>;
    },
    code?: TProgramErrorCode
): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &
    Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {
    return isProgramError<TProgramErrorCode>(
        error,
        transactionMessage,
        TESTUDO_BONDS_PROGRAM_ADDRESS,
        code
    );
}

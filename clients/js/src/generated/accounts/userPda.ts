/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertAccountExists,
    assertAccountsExist,
    combineCodec,
    decodeAccount,
    fetchEncodedAccount,
    fetchEncodedAccounts,
    getAddressDecoder,
    getAddressEncoder,
    getArrayDecoder,
    getArrayEncoder,
    getStructDecoder,
    getStructEncoder,
    getTupleDecoder,
    getTupleEncoder,
    getU64Decoder,
    getU64Encoder,
    getU8Decoder,
    getU8Encoder,
    type Account,
    type Address,
    type Codec,
    type Decoder,
    type EncodedAccount,
    type Encoder,
    type FetchAccountConfig,
    type FetchAccountsConfig,
    type MaybeAccount,
    type MaybeEncodedAccount,
} from '@solana/kit';
import { UserPdaSeeds, findUserPdaPda } from '../pdas';

export type UserPda = {
    user: Address;
    bondCount: number;
    totalAccruedRewards: bigint;
    activeBonds: Array<readonly [number, Address]>;
    bondIndex: number;
};

export type UserPdaArgs = {
    user: Address;
    bondCount: number;
    totalAccruedRewards: number | bigint;
    activeBonds: Array<readonly [number, Address]>;
    bondIndex: number;
};

export function getUserPdaEncoder(): Encoder<UserPdaArgs> {
    return getStructEncoder([
        ['user', getAddressEncoder()],
        ['bondCount', getU8Encoder()],
        ['totalAccruedRewards', getU64Encoder()],
        [
            'activeBonds',
            getArrayEncoder(
                getTupleEncoder([getU8Encoder(), getAddressEncoder()])
            ),
        ],
        ['bondIndex', getU8Encoder()],
    ]);
}

export function getUserPdaDecoder(): Decoder<UserPda> {
    return getStructDecoder([
        ['user', getAddressDecoder()],
        ['bondCount', getU8Decoder()],
        ['totalAccruedRewards', getU64Decoder()],
        [
            'activeBonds',
            getArrayDecoder(
                getTupleDecoder([getU8Decoder(), getAddressDecoder()])
            ),
        ],
        ['bondIndex', getU8Decoder()],
    ]);
}

export function getUserPdaCodec(): Codec<UserPdaArgs, UserPda> {
    return combineCodec(getUserPdaEncoder(), getUserPdaDecoder());
}

export function decodeUserPda<TAddress extends string = string>(
    encodedAccount: EncodedAccount<TAddress>
): Account<UserPda, TAddress>;
export function decodeUserPda<TAddress extends string = string>(
    encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<UserPda, TAddress>;
export function decodeUserPda<TAddress extends string = string>(
    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<UserPda, TAddress> | MaybeAccount<UserPda, TAddress> {
    return decodeAccount(
        encodedAccount as MaybeEncodedAccount<TAddress>,
        getUserPdaDecoder()
    );
}

export async function fetchUserPda<TAddress extends string = string>(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    address: Address<TAddress>,
    config?: FetchAccountConfig
): Promise<Account<UserPda, TAddress>> {
    const maybeAccount = await fetchMaybeUserPda(rpc, address, config);
    assertAccountExists(maybeAccount);
    return maybeAccount;
}

export async function fetchMaybeUserPda<TAddress extends string = string>(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    address: Address<TAddress>,
    config?: FetchAccountConfig
): Promise<MaybeAccount<UserPda, TAddress>> {
    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
    return decodeUserPda(maybeAccount);
}

export async function fetchAllUserPda(
    rpc: Parameters<typeof fetchEncodedAccounts>[0],
    addresses: Array<Address>,
    config?: FetchAccountsConfig
): Promise<Account<UserPda>[]> {
    const maybeAccounts = await fetchAllMaybeUserPda(rpc, addresses, config);
    assertAccountsExist(maybeAccounts);
    return maybeAccounts;
}

export async function fetchAllMaybeUserPda(
    rpc: Parameters<typeof fetchEncodedAccounts>[0],
    addresses: Array<Address>,
    config?: FetchAccountsConfig
): Promise<MaybeAccount<UserPda>[]> {
    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
    return maybeAccounts.map((maybeAccount) => decodeUserPda(maybeAccount));
}

export async function fetchUserPdaFromSeeds(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    seeds: UserPdaSeeds,
    config: FetchAccountConfig & { programAddress?: Address } = {}
): Promise<Account<UserPda>> {
    const maybeAccount = await fetchMaybeUserPdaFromSeeds(rpc, seeds, config);
    assertAccountExists(maybeAccount);
    return maybeAccount;
}

export async function fetchMaybeUserPdaFromSeeds(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    seeds: UserPdaSeeds,
    config: FetchAccountConfig & { programAddress?: Address } = {}
): Promise<MaybeAccount<UserPda>> {
    const { programAddress, ...fetchConfig } = config;
    const [address] = await findUserPdaPda(seeds, { programAddress });
    return await fetchMaybeUserPda(rpc, address, fetchConfig);
}

export function getUserPdaSize(): number {
    // Based on Rust UserAccount::SIZE = 32 + 1 + 8 + (4 + (10 * (32 + 1))) + 1
    // user: Pubkey (32) + bond_count: u8 (1) + total_accrued_rewards: u64 (8) + 
    // active_bonds: Vec<(u8, Pubkey)> (4 + 10 * (1 + 32)) + bond_index: u8 (1)
    return 32 + 1 + 8 + (4 + (10 * (32 + 1))) + 1;
}

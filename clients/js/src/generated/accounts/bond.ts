/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertAccountExists,
    assertAccountsExist,
    combineCodec,
    decodeAccount,
    fetchEncodedAccount,
    fetchEncodedAccounts,
    getAddressDecoder,
    getAddressEncoder,
    getBooleanDecoder,
    getBooleanEncoder,
    getI64Decoder,
    getI64Encoder,
    getStructDecoder,
    getStructEncoder,
    getU64Decoder,
    getU64Encoder,
    getU8Decoder,
    getU8Encoder,
    type Account,
    type Address,
    type Codec,
    type Decoder,
    type EncodedAccount,
    type Encoder,
    type FetchAccountConfig,
    type FetchAccountsConfig,
    type MaybeAccount,
    type MaybeEncodedAccount,
} from '@solana/kit';
import { BondSeeds, findBondPda } from '../pdas';

export type Bond = {
    owner: Address;
    bondIndex: number;
    creationTimestamp: bigint;
    lastClaimTimestamp: bigint;
    totalClaimed: bigint;
    isActive: boolean;
};

export type BondArgs = {
    owner: Address;
    bondIndex: number;
    creationTimestamp: number | bigint;
    lastClaimTimestamp: number | bigint;
    totalClaimed: number | bigint;
    isActive: boolean;
};

export function getBondEncoder(): Encoder<BondArgs> {
    return getStructEncoder([
        ['owner', getAddressEncoder()],
        ['bondIndex', getU8Encoder()],
        ['creationTimestamp', getI64Encoder()],
        ['lastClaimTimestamp', getI64Encoder()],
        ['totalClaimed', getU64Encoder()],
        ['isActive', getBooleanEncoder()],
    ]);
}

export function getBondDecoder(): Decoder<Bond> {
    return getStructDecoder([
        ['owner', getAddressDecoder()],
        ['bondIndex', getU8Decoder()],
        ['creationTimestamp', getI64Decoder()],
        ['lastClaimTimestamp', getI64Decoder()],
        ['totalClaimed', getU64Decoder()],
        ['isActive', getBooleanDecoder()],
    ]);
}

export function getBondCodec(): Codec<BondArgs, Bond> {
    return combineCodec(getBondEncoder(), getBondDecoder());
}

export function decodeBond<TAddress extends string = string>(
    encodedAccount: EncodedAccount<TAddress>
): Account<Bond, TAddress>;
export function decodeBond<TAddress extends string = string>(
    encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Bond, TAddress>;
export function decodeBond<TAddress extends string = string>(
    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Bond, TAddress> | MaybeAccount<Bond, TAddress> {
    return decodeAccount(
        encodedAccount as MaybeEncodedAccount<TAddress>,
        getBondDecoder()
    );
}

export async function fetchBond<TAddress extends string = string>(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    address: Address<TAddress>,
    config?: FetchAccountConfig
): Promise<Account<Bond, TAddress>> {
    const maybeAccount = await fetchMaybeBond(rpc, address, config);
    assertAccountExists(maybeAccount);
    return maybeAccount;
}

export async function fetchMaybeBond<TAddress extends string = string>(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    address: Address<TAddress>,
    config?: FetchAccountConfig
): Promise<MaybeAccount<Bond, TAddress>> {
    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
    return decodeBond(maybeAccount);
}

export async function fetchAllBond(
    rpc: Parameters<typeof fetchEncodedAccounts>[0],
    addresses: Array<Address>,
    config?: FetchAccountsConfig
): Promise<Account<Bond>[]> {
    const maybeAccounts = await fetchAllMaybeBond(rpc, addresses, config);
    assertAccountsExist(maybeAccounts);
    return maybeAccounts;
}

export async function fetchAllMaybeBond(
    rpc: Parameters<typeof fetchEncodedAccounts>[0],
    addresses: Array<Address>,
    config?: FetchAccountsConfig
): Promise<MaybeAccount<Bond>[]> {
    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
    return maybeAccounts.map((maybeAccount) => decodeBond(maybeAccount));
}

export function getBondSize(): number {
    return 58;
}

export async function fetchBondFromSeeds(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    seeds: BondSeeds,
    config: FetchAccountConfig & { programAddress?: Address } = {}
): Promise<Account<Bond>> {
    const maybeAccount = await fetchMaybeBondFromSeeds(rpc, seeds, config);
    assertAccountExists(maybeAccount);
    return maybeAccount;
}

export async function fetchMaybeBondFromSeeds(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    seeds: BondSeeds,
    config: FetchAccountConfig & { programAddress?: Address } = {}
): Promise<MaybeAccount<Bond>> {
    const { programAddress, ...fetchConfig } = config;
    const [address] = await findBondPda(seeds, { programAddress });
    return await fetchMaybeBond(rpc, address, fetchConfig);
}

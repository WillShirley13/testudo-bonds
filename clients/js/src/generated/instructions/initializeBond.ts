/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    BASE_ACCOUNT_SIZE,
    combineCodec,
    getStructDecoder,
    getStructEncoder,
    getU8Decoder,
    getU8Encoder,
    transformEncoder,
    type Address,
    type Codec,
    type Decoder,
    type Encoder,
    type IAccountMeta,
    type IAccountSignerMeta,
    type IInstruction,
    type IInstructionWithAccounts,
    type IInstructionWithData,
    type ReadonlyAccount,
    type ReadonlySignerAccount,
    type TransactionSigner,
    type WritableAccount,
} from '@solana/kit';
import { getBondSize } from '../accounts';
import { findGlobalAdminPda, findUserPdaPda } from '../pdas';
import { TESTUDO_BONDS_PROGRAM_ADDRESS } from '../programs';
import {
    expectAddress,
    getAccountMetaFactory,
    type IInstructionWithByteDelta,
    type ResolvedAccount,
} from '../shared';

export const INITIALIZE_BOND_DISCRIMINATOR = 2;

export function getInitializeBondDiscriminatorBytes() {
    return getU8Encoder().encode(INITIALIZE_BOND_DISCRIMINATOR);
}

export type InitializeBondInstruction<
    TProgram extends string = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
    TAccountBond extends string | IAccountMeta<string> = string,
    TAccountUserWallet extends string | IAccountMeta<string> = string,
    TAccountUserPda extends string | IAccountMeta<string> = string,
    TAccountGlobalAdmin extends string | IAccountMeta<string> = string,
    TAccountUserWalletAta extends string | IAccountMeta<string> = string,
    TAccountRewardsPoolAta extends string | IAccountMeta<string> = string,
    TAccountTreasuryAta extends string | IAccountMeta<string> = string,
    TAccountTeamAta extends string | IAccountMeta<string> = string,
    TAccountNativeTokenMint extends string | IAccountMeta<string> = string,
    TAccountSystemProgram extends
        | string
        | IAccountMeta<string> = '11111111111111111111111111111111',
    TAccountTokenProgram extends
        | string
        | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
    TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
    IInstructionWithData<Uint8Array> &
    IInstructionWithAccounts<
        [
            TAccountBond extends string
                ? WritableAccount<TAccountBond>
                : TAccountBond,
            TAccountUserWallet extends string
                ? ReadonlySignerAccount<TAccountUserWallet> &
                      IAccountSignerMeta<TAccountUserWallet>
                : TAccountUserWallet,
            TAccountUserPda extends string
                ? WritableAccount<TAccountUserPda>
                : TAccountUserPda,
            TAccountGlobalAdmin extends string
                ? ReadonlyAccount<TAccountGlobalAdmin>
                : TAccountGlobalAdmin,
            TAccountUserWalletAta extends string
                ? WritableAccount<TAccountUserWalletAta>
                : TAccountUserWalletAta,
            TAccountRewardsPoolAta extends string
                ? WritableAccount<TAccountRewardsPoolAta>
                : TAccountRewardsPoolAta,
            TAccountTreasuryAta extends string
                ? WritableAccount<TAccountTreasuryAta>
                : TAccountTreasuryAta,
            TAccountTeamAta extends string
                ? WritableAccount<TAccountTeamAta>
                : TAccountTeamAta,
            TAccountNativeTokenMint extends string
                ? ReadonlyAccount<TAccountNativeTokenMint>
                : TAccountNativeTokenMint,
            TAccountSystemProgram extends string
                ? ReadonlyAccount<TAccountSystemProgram>
                : TAccountSystemProgram,
            TAccountTokenProgram extends string
                ? ReadonlyAccount<TAccountTokenProgram>
                : TAccountTokenProgram,
            ...TRemainingAccounts,
        ]
    >;

export type InitializeBondInstructionData = { discriminator: number };

export type InitializeBondInstructionDataArgs = {};

export function getInitializeBondInstructionDataEncoder(): Encoder<InitializeBondInstructionDataArgs> {
    return transformEncoder(
        getStructEncoder([['discriminator', getU8Encoder()]]),
        (value) => ({ ...value, discriminator: INITIALIZE_BOND_DISCRIMINATOR })
    );
}

export function getInitializeBondInstructionDataDecoder(): Decoder<InitializeBondInstructionData> {
    return getStructDecoder([['discriminator', getU8Decoder()]]);
}

export function getInitializeBondInstructionDataCodec(): Codec<
    InitializeBondInstructionDataArgs,
    InitializeBondInstructionData
> {
    return combineCodec(
        getInitializeBondInstructionDataEncoder(),
        getInitializeBondInstructionDataDecoder()
    );
}

export type InitializeBondAsyncInput<
    TAccountBond extends string = string,
    TAccountUserWallet extends string = string,
    TAccountUserPda extends string = string,
    TAccountGlobalAdmin extends string = string,
    TAccountUserWalletAta extends string = string,
    TAccountRewardsPoolAta extends string = string,
    TAccountTreasuryAta extends string = string,
    TAccountTeamAta extends string = string,
    TAccountNativeTokenMint extends string = string,
    TAccountSystemProgram extends string = string,
    TAccountTokenProgram extends string = string,
> = {
    /** The program derived address of the bond account to create (seeds: ['bond', user_pda, bond_index]) */
    bond?: Address<TAccountBond>;
    /** The wallet of the user */
    userWallet: TransactionSigner<TAccountUserWallet>;
    /** The user's pda */
    userPda?: Address<TAccountUserPda>;
    /** The global admin account */
    globalAdmin?: Address<TAccountGlobalAdmin>;
    /** The user's wallet token account */
    userWalletAta: Address<TAccountUserWalletAta>;
    /** The rewards pool (token account) of the global admin */
    rewardsPoolAta: Address<TAccountRewardsPoolAta>;
    /** The token account of the treasury */
    treasuryAta: Address<TAccountTreasuryAta>;
    /** The token account of the team */
    teamAta: Address<TAccountTeamAta>;
    /** The native token mint */
    nativeTokenMint: Address<TAccountNativeTokenMint>;
    /** The system program */
    systemProgram?: Address<TAccountSystemProgram>;
    /** The token program */
    tokenProgram?: Address<TAccountTokenProgram>;
};

export async function getInitializeBondInstructionAsync<
    TAccountBond extends string,
    TAccountUserWallet extends string,
    TAccountUserPda extends string,
    TAccountGlobalAdmin extends string,
    TAccountUserWalletAta extends string,
    TAccountRewardsPoolAta extends string,
    TAccountTreasuryAta extends string,
    TAccountTeamAta extends string,
    TAccountNativeTokenMint extends string,
    TAccountSystemProgram extends string,
    TAccountTokenProgram extends string,
    TProgramAddress extends Address = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
>(
    input: InitializeBondAsyncInput<
        TAccountBond,
        TAccountUserWallet,
        TAccountUserPda,
        TAccountGlobalAdmin,
        TAccountUserWalletAta,
        TAccountRewardsPoolAta,
        TAccountTreasuryAta,
        TAccountTeamAta,
        TAccountNativeTokenMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >,
    config?: { programAddress?: TProgramAddress }
): Promise<
    InitializeBondInstruction<
        TProgramAddress,
        TAccountBond,
        TAccountUserWallet,
        TAccountUserPda,
        TAccountGlobalAdmin,
        TAccountUserWalletAta,
        TAccountRewardsPoolAta,
        TAccountTreasuryAta,
        TAccountTeamAta,
        TAccountNativeTokenMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    > &
        IInstructionWithByteDelta
> {
    // Program address.
    const programAddress =
        config?.programAddress ?? TESTUDO_BONDS_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        bond: { value: input.bond ?? null, isWritable: true },
        userWallet: { value: input.userWallet ?? null, isWritable: false },
        userPda: { value: input.userPda ?? null, isWritable: true },
        globalAdmin: { value: input.globalAdmin ?? null, isWritable: false },
        userWalletAta: { value: input.userWalletAta ?? null, isWritable: true },
        rewardsPoolAta: {
            value: input.rewardsPoolAta ?? null,
            isWritable: true,
        },
        treasuryAta: { value: input.treasuryAta ?? null, isWritable: true },
        teamAta: { value: input.teamAta ?? null, isWritable: true },
        nativeTokenMint: {
            value: input.nativeTokenMint ?? null,
            isWritable: false,
        },
        systemProgram: {
            value: input.systemProgram ?? null,
            isWritable: false,
        },
        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    };
    const accounts = originalAccounts as Record<
        keyof typeof originalAccounts,
        ResolvedAccount
    >;

    // Resolve default values.
    if (!accounts.userPda.value) {
        accounts.userPda.value = await findUserPdaPda({
            userWallet: expectAddress(accounts.userWallet.value),
        });
    }
    if (!accounts.bond.value) {
        // Note: bondIndex should be provided by the caller based on user account data
        // This is a limitation of the generated code - it cannot fetch account data
        throw new Error('Bond account must be provided explicitly with correct bondIndex');
    }
    if (!accounts.globalAdmin.value) {
        accounts.globalAdmin.value = await findGlobalAdminPda();
    }
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
    }
    if (!accounts.tokenProgram.value) {
        accounts.tokenProgram.value =
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
    }

    // Bytes created or reallocated by the instruction.
    const byteDelta: number = [getBondSize() + BASE_ACCOUNT_SIZE].reduce(
        (a, b) => a + b,
        0
    );

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {
        accounts: [
            getAccountMeta(accounts.bond),
            getAccountMeta(accounts.userWallet),
            getAccountMeta(accounts.userPda),
            getAccountMeta(accounts.globalAdmin),
            getAccountMeta(accounts.userWalletAta),
            getAccountMeta(accounts.rewardsPoolAta),
            getAccountMeta(accounts.treasuryAta),
            getAccountMeta(accounts.teamAta),
            getAccountMeta(accounts.nativeTokenMint),
            getAccountMeta(accounts.systemProgram),
            getAccountMeta(accounts.tokenProgram),
        ],
        programAddress,
        data: getInitializeBondInstructionDataEncoder().encode({}),
    } as InitializeBondInstruction<
        TProgramAddress,
        TAccountBond,
        TAccountUserWallet,
        TAccountUserPda,
        TAccountGlobalAdmin,
        TAccountUserWalletAta,
        TAccountRewardsPoolAta,
        TAccountTreasuryAta,
        TAccountTeamAta,
        TAccountNativeTokenMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >;

    return Object.freeze({ ...instruction, byteDelta });
}

export type InitializeBondInput<
    TAccountBond extends string = string,
    TAccountUserWallet extends string = string,
    TAccountUserPda extends string = string,
    TAccountGlobalAdmin extends string = string,
    TAccountUserWalletAta extends string = string,
    TAccountRewardsPoolAta extends string = string,
    TAccountTreasuryAta extends string = string,
    TAccountTeamAta extends string = string,
    TAccountNativeTokenMint extends string = string,
    TAccountSystemProgram extends string = string,
    TAccountTokenProgram extends string = string,
> = {
    /** The program derived address of the bond account to create (seeds: ['bond', user_pda, bond_index]) */
    bond: Address<TAccountBond>;
    /** The wallet of the user */
    userWallet: TransactionSigner<TAccountUserWallet>;
    /** The user's pda */
    userPda: Address<TAccountUserPda>;
    /** The global admin account */
    globalAdmin: Address<TAccountGlobalAdmin>;
    /** The user's wallet token account */
    userWalletAta: Address<TAccountUserWalletAta>;
    /** The rewards pool (token account) of the global admin */
    rewardsPoolAta: Address<TAccountRewardsPoolAta>;
    /** The token account of the treasury */
    treasuryAta: Address<TAccountTreasuryAta>;
    /** The token account of the team */
    teamAta: Address<TAccountTeamAta>;
    /** The native token mint */
    nativeTokenMint: Address<TAccountNativeTokenMint>;
    /** The system program */
    systemProgram?: Address<TAccountSystemProgram>;
    /** The token program */
    tokenProgram?: Address<TAccountTokenProgram>;
};

export function getInitializeBondInstruction<
    TAccountBond extends string,
    TAccountUserWallet extends string,
    TAccountUserPda extends string,
    TAccountGlobalAdmin extends string,
    TAccountUserWalletAta extends string,
    TAccountRewardsPoolAta extends string,
    TAccountTreasuryAta extends string,
    TAccountTeamAta extends string,
    TAccountNativeTokenMint extends string,
    TAccountSystemProgram extends string,
    TAccountTokenProgram extends string,
    TProgramAddress extends Address = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
>(
    input: InitializeBondInput<
        TAccountBond,
        TAccountUserWallet,
        TAccountUserPda,
        TAccountGlobalAdmin,
        TAccountUserWalletAta,
        TAccountRewardsPoolAta,
        TAccountTreasuryAta,
        TAccountTeamAta,
        TAccountNativeTokenMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >,
    config?: { programAddress?: TProgramAddress }
): InitializeBondInstruction<
    TProgramAddress,
    TAccountBond,
    TAccountUserWallet,
    TAccountUserPda,
    TAccountGlobalAdmin,
    TAccountUserWalletAta,
    TAccountRewardsPoolAta,
    TAccountTreasuryAta,
    TAccountTeamAta,
    TAccountNativeTokenMint,
    TAccountSystemProgram,
    TAccountTokenProgram
> &
    IInstructionWithByteDelta {
    // Program address.
    const programAddress =
        config?.programAddress ?? TESTUDO_BONDS_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        bond: { value: input.bond ?? null, isWritable: true },
        userWallet: { value: input.userWallet ?? null, isWritable: false },
        userPda: { value: input.userPda ?? null, isWritable: true },
        globalAdmin: { value: input.globalAdmin ?? null, isWritable: false },
        userWalletAta: { value: input.userWalletAta ?? null, isWritable: true },
        rewardsPoolAta: {
            value: input.rewardsPoolAta ?? null,
            isWritable: true,
        },
        treasuryAta: { value: input.treasuryAta ?? null, isWritable: true },
        teamAta: { value: input.teamAta ?? null, isWritable: true },
        nativeTokenMint: {
            value: input.nativeTokenMint ?? null,
            isWritable: false,
        },
        systemProgram: {
            value: input.systemProgram ?? null,
            isWritable: false,
        },
        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    };
    const accounts = originalAccounts as Record<
        keyof typeof originalAccounts,
        ResolvedAccount
    >;

    // Resolve default values.
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
    }
    if (!accounts.tokenProgram.value) {
        accounts.tokenProgram.value =
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
    }

    // Bytes created or reallocated by the instruction.
    const byteDelta: number = [getBondSize() + BASE_ACCOUNT_SIZE].reduce(
        (a, b) => a + b,
        0
    );

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {
        accounts: [
            getAccountMeta(accounts.bond),
            getAccountMeta(accounts.userWallet),
            getAccountMeta(accounts.userPda),
            getAccountMeta(accounts.globalAdmin),
            getAccountMeta(accounts.userWalletAta),
            getAccountMeta(accounts.rewardsPoolAta),
            getAccountMeta(accounts.treasuryAta),
            getAccountMeta(accounts.teamAta),
            getAccountMeta(accounts.nativeTokenMint),
            getAccountMeta(accounts.systemProgram),
            getAccountMeta(accounts.tokenProgram),
        ],
        programAddress,
        data: getInitializeBondInstructionDataEncoder().encode({}),
    } as InitializeBondInstruction<
        TProgramAddress,
        TAccountBond,
        TAccountUserWallet,
        TAccountUserPda,
        TAccountGlobalAdmin,
        TAccountUserWalletAta,
        TAccountRewardsPoolAta,
        TAccountTreasuryAta,
        TAccountTeamAta,
        TAccountNativeTokenMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >;

    return Object.freeze({ ...instruction, byteDelta });
}

export type ParsedInitializeBondInstruction<
    TProgram extends string = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
    TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
    programAddress: Address<TProgram>;
    accounts: {
        /** The program derived address of the bond account to create (seeds: ['bond', user_pda, bond_index]) */
        bond: TAccountMetas[0];
        /** The wallet of the user */
        userWallet: TAccountMetas[1];
        /** The user's pda */
        userPda: TAccountMetas[2];
        /** The global admin account */
        globalAdmin: TAccountMetas[3];
        /** The user's wallet token account */
        userWalletAta: TAccountMetas[4];
        /** The rewards pool (token account) of the global admin */
        rewardsPoolAta: TAccountMetas[5];
        /** The token account of the treasury */
        treasuryAta: TAccountMetas[6];
        /** The token account of the team */
        teamAta: TAccountMetas[7];
        /** The native token mint */
        nativeTokenMint: TAccountMetas[8];
        /** The system program */
        systemProgram: TAccountMetas[9];
        /** The token program */
        tokenProgram: TAccountMetas[10];
    };
    data: InitializeBondInstructionData;
};

export function parseInitializeBondInstruction<
    TProgram extends string,
    TAccountMetas extends readonly IAccountMeta[],
>(
    instruction: IInstruction<TProgram> &
        IInstructionWithAccounts<TAccountMetas> &
        IInstructionWithData<Uint8Array>
): ParsedInitializeBondInstruction<TProgram, TAccountMetas> {
    if (instruction.accounts.length < 11) {
        // TODO: Coded error.
        throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = instruction.accounts![accountIndex]!;
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            bond: getNextAccount(),
            userWallet: getNextAccount(),
            userPda: getNextAccount(),
            globalAdmin: getNextAccount(),
            userWalletAta: getNextAccount(),
            rewardsPoolAta: getNextAccount(),
            treasuryAta: getNextAccount(),
            teamAta: getNextAccount(),
            nativeTokenMint: getNextAccount(),
            systemProgram: getNextAccount(),
            tokenProgram: getNextAccount(),
        },
        data: getInitializeBondInstructionDataDecoder().decode(
            instruction.data
        ),
    };
}

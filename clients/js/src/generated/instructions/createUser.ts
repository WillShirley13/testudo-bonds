/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    BASE_ACCOUNT_SIZE,
    combineCodec,
    getStructDecoder,
    getStructEncoder,
    getU8Decoder,
    getU8Encoder,
    transformEncoder,
    type Address,
    type Codec,
    type Decoder,
    type Encoder,
    type IAccountMeta,
    type IAccountSignerMeta,
    type IInstruction,
    type IInstructionWithAccounts,
    type IInstructionWithData,
    type ReadonlyAccount,
    type ReadonlySignerAccount,
    type TransactionSigner,
    type WritableAccount,
} from '@solana/kit';
import { getUserPdaSize } from '../accounts';
import { findUserPdaPda } from '../pdas';
import { TESTUDO_BONDS_PROGRAM_ADDRESS } from '../programs';
import {
    expectAddress,
    getAccountMetaFactory,
    type IInstructionWithByteDelta,
    type ResolvedAccount,
} from '../shared';

export const CREATE_USER_DISCRIMINATOR = 1;

export function getCreateUserDiscriminatorBytes() {
    return getU8Encoder().encode(CREATE_USER_DISCRIMINATOR);
}

export type CreateUserInstruction<
    TProgram extends string = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
    TAccountUserPda extends string | IAccountMeta<string> = string,
    TAccountUserWallet extends string | IAccountMeta<string> = string,
    TAccountSystemProgram extends
        | string
        | IAccountMeta<string> = '11111111111111111111111111111111',
    TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
    IInstructionWithData<Uint8Array> &
    IInstructionWithAccounts<
        [
            TAccountUserPda extends string
                ? WritableAccount<TAccountUserPda>
                : TAccountUserPda,
            TAccountUserWallet extends string
                ? ReadonlySignerAccount<TAccountUserWallet> &
                      IAccountSignerMeta<TAccountUserWallet>
                : TAccountUserWallet,
            TAccountSystemProgram extends string
                ? ReadonlyAccount<TAccountSystemProgram>
                : TAccountSystemProgram,
            ...TRemainingAccounts,
        ]
    >;

export type CreateUserInstructionData = { discriminator: number };

export type CreateUserInstructionDataArgs = {};

export function getCreateUserInstructionDataEncoder(): Encoder<CreateUserInstructionDataArgs> {
    return transformEncoder(
        getStructEncoder([['discriminator', getU8Encoder()]]),
        (value) => ({ ...value, discriminator: CREATE_USER_DISCRIMINATOR })
    );
}

export function getCreateUserInstructionDataDecoder(): Decoder<CreateUserInstructionData> {
    return getStructDecoder([['discriminator', getU8Decoder()]]);
}

export function getCreateUserInstructionDataCodec(): Codec<
    CreateUserInstructionDataArgs,
    CreateUserInstructionData
> {
    return combineCodec(
        getCreateUserInstructionDataEncoder(),
        getCreateUserInstructionDataDecoder()
    );
}

export type CreateUserAsyncInput<
    TAccountUserPda extends string = string,
    TAccountUserWallet extends string = string,
    TAccountSystemProgram extends string = string,
> = {
    /** The program derived address of the user account to create (seeds: ['user', wallet_pubkey]) */
    userPda?: Address<TAccountUserPda>;
    /** The wallet of the user */
    userWallet: TransactionSigner<TAccountUserWallet>;
    /** The system program */
    systemProgram?: Address<TAccountSystemProgram>;
};

export async function getCreateUserInstructionAsync<
    TAccountUserPda extends string,
    TAccountUserWallet extends string,
    TAccountSystemProgram extends string,
    TProgramAddress extends Address = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
>(
    input: CreateUserAsyncInput<
        TAccountUserPda,
        TAccountUserWallet,
        TAccountSystemProgram
    >,
    config?: { programAddress?: TProgramAddress }
): Promise<
    CreateUserInstruction<
        TProgramAddress,
        TAccountUserPda,
        TAccountUserWallet,
        TAccountSystemProgram
    > &
        IInstructionWithByteDelta
> {
    // Program address.
    const programAddress =
        config?.programAddress ?? TESTUDO_BONDS_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        userPda: { value: input.userPda ?? null, isWritable: true },
        userWallet: { value: input.userWallet ?? null, isWritable: false },
        systemProgram: {
            value: input.systemProgram ?? null,
            isWritable: false,
        },
    };
    const accounts = originalAccounts as Record<
        keyof typeof originalAccounts,
        ResolvedAccount
    >;

    // Resolve default values.
    if (!accounts.userPda.value) {
        accounts.userPda.value = await findUserPdaPda({
            userWallet: expectAddress(accounts.userWallet.value),
        });
    }
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
    }

    // Bytes created or reallocated by the instruction.
    const byteDelta: number = [getUserPdaSize() + BASE_ACCOUNT_SIZE].reduce(
        (a, b) => a + b,
        0
    );

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {
        accounts: [
            getAccountMeta(accounts.userPda),
            getAccountMeta(accounts.userWallet),
            getAccountMeta(accounts.systemProgram),
        ],
        programAddress,
        data: getCreateUserInstructionDataEncoder().encode({}),
    } as CreateUserInstruction<
        TProgramAddress,
        TAccountUserPda,
        TAccountUserWallet,
        TAccountSystemProgram
    >;

    return Object.freeze({ ...instruction, byteDelta });
}

export type CreateUserInput<
    TAccountUserPda extends string = string,
    TAccountUserWallet extends string = string,
    TAccountSystemProgram extends string = string,
> = {
    /** The program derived address of the user account to create (seeds: ['user', wallet_pubkey]) */
    userPda: Address<TAccountUserPda>;
    /** The wallet of the user */
    userWallet: TransactionSigner<TAccountUserWallet>;
    /** The system program */
    systemProgram?: Address<TAccountSystemProgram>;
};

export function getCreateUserInstruction<
    TAccountUserPda extends string,
    TAccountUserWallet extends string,
    TAccountSystemProgram extends string,
    TProgramAddress extends Address = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
>(
    input: CreateUserInput<
        TAccountUserPda,
        TAccountUserWallet,
        TAccountSystemProgram
    >,
    config?: { programAddress?: TProgramAddress }
): CreateUserInstruction<
    TProgramAddress,
    TAccountUserPda,
    TAccountUserWallet,
    TAccountSystemProgram
> &
    IInstructionWithByteDelta {
    // Program address.
    const programAddress =
        config?.programAddress ?? TESTUDO_BONDS_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        userPda: { value: input.userPda ?? null, isWritable: true },
        userWallet: { value: input.userWallet ?? null, isWritable: false },
        systemProgram: {
            value: input.systemProgram ?? null,
            isWritable: false,
        },
    };
    const accounts = originalAccounts as Record<
        keyof typeof originalAccounts,
        ResolvedAccount
    >;

    // Resolve default values.
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
    }

    // Bytes created or reallocated by the instruction.
    const byteDelta: number = [getUserPdaSize() + BASE_ACCOUNT_SIZE].reduce(
        (a, b) => a + b,
        0
    );

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {
        accounts: [
            getAccountMeta(accounts.userPda),
            getAccountMeta(accounts.userWallet),
            getAccountMeta(accounts.systemProgram),
        ],
        programAddress,
        data: getCreateUserInstructionDataEncoder().encode({}),
    } as CreateUserInstruction<
        TProgramAddress,
        TAccountUserPda,
        TAccountUserWallet,
        TAccountSystemProgram
    >;

    return Object.freeze({ ...instruction, byteDelta });
}

export type ParsedCreateUserInstruction<
    TProgram extends string = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
    TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
    programAddress: Address<TProgram>;
    accounts: {
        /** The program derived address of the user account to create (seeds: ['user', wallet_pubkey]) */
        userPda: TAccountMetas[0];
        /** The wallet of the user */
        userWallet: TAccountMetas[1];
        /** The system program */
        systemProgram: TAccountMetas[2];
    };
    data: CreateUserInstructionData;
};

export function parseCreateUserInstruction<
    TProgram extends string,
    TAccountMetas extends readonly IAccountMeta[],
>(
    instruction: IInstruction<TProgram> &
        IInstructionWithAccounts<TAccountMetas> &
        IInstructionWithData<Uint8Array>
): ParsedCreateUserInstruction<TProgram, TAccountMetas> {
    if (instruction.accounts.length < 3) {
        // TODO: Coded error.
        throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = instruction.accounts![accountIndex]!;
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            userPda: getNextAccount(),
            userWallet: getNextAccount(),
            systemProgram: getNextAccount(),
        },
        data: getCreateUserInstructionDataDecoder().decode(instruction.data),
    };
}

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    combineCodec,
    getStructDecoder,
    getStructEncoder,
    getU8Decoder,
    getU8Encoder,
    transformEncoder,
    type Address,
    type Codec,
    type Decoder,
    type Encoder,
    type IAccountMeta,
    type IAccountSignerMeta,
    type IInstruction,
    type IInstructionWithAccounts,
    type IInstructionWithData,
    type ReadonlySignerAccount,
    type TransactionSigner,
    type WritableAccount,
} from '@solana/kit';
import { findGlobalAdminPda } from '../pdas';
import { TESTUDO_BONDS_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const UPDATE_ADMIN_DISCRIMINATOR = 4;

export function getUpdateAdminDiscriminatorBytes() {
    return getU8Encoder().encode(UPDATE_ADMIN_DISCRIMINATOR);
}

export type UpdateAdminInstruction<
    TProgram extends string = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
    TAccountGlobalAdmin extends string | IAccountMeta<string> = string,
    TAccountAuthority extends string | IAccountMeta<string> = string,
    TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
    IInstructionWithData<Uint8Array> &
    IInstructionWithAccounts<
        [
            TAccountGlobalAdmin extends string
                ? WritableAccount<TAccountGlobalAdmin>
                : TAccountGlobalAdmin,
            TAccountAuthority extends string
                ? ReadonlySignerAccount<TAccountAuthority> &
                      IAccountSignerMeta<TAccountAuthority>
                : TAccountAuthority,
            ...TRemainingAccounts,
        ]
    >;

export type UpdateAdminInstructionData = { discriminator: number };

export type UpdateAdminInstructionDataArgs = {};

export function getUpdateAdminInstructionDataEncoder(): Encoder<UpdateAdminInstructionDataArgs> {
    return transformEncoder(
        getStructEncoder([['discriminator', getU8Encoder()]]),
        (value) => ({ ...value, discriminator: UPDATE_ADMIN_DISCRIMINATOR })
    );
}

export function getUpdateAdminInstructionDataDecoder(): Decoder<UpdateAdminInstructionData> {
    return getStructDecoder([['discriminator', getU8Decoder()]]);
}

export function getUpdateAdminInstructionDataCodec(): Codec<
    UpdateAdminInstructionDataArgs,
    UpdateAdminInstructionData
> {
    return combineCodec(
        getUpdateAdminInstructionDataEncoder(),
        getUpdateAdminInstructionDataDecoder()
    );
}

export type UpdateAdminAsyncInput<
    TAccountGlobalAdmin extends string = string,
    TAccountAuthority extends string = string,
> = {
    /** The program derived address of the global admin account to update (seeds: ['global_admin']) */
    globalAdmin?: Address<TAccountGlobalAdmin>;
    /** The authority of the global admin */
    authority: TransactionSigner<TAccountAuthority>;
};

export async function getUpdateAdminInstructionAsync<
    TAccountGlobalAdmin extends string,
    TAccountAuthority extends string,
    TProgramAddress extends Address = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
>(
    input: UpdateAdminAsyncInput<TAccountGlobalAdmin, TAccountAuthority>,
    config?: { programAddress?: TProgramAddress }
): Promise<
    UpdateAdminInstruction<
        TProgramAddress,
        TAccountGlobalAdmin,
        TAccountAuthority
    >
> {
    // Program address.
    const programAddress =
        config?.programAddress ?? TESTUDO_BONDS_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        globalAdmin: { value: input.globalAdmin ?? null, isWritable: true },
        authority: { value: input.authority ?? null, isWritable: false },
    };
    const accounts = originalAccounts as Record<
        keyof typeof originalAccounts,
        ResolvedAccount
    >;

    // Resolve default values.
    if (!accounts.globalAdmin.value) {
        accounts.globalAdmin.value = await findGlobalAdminPda();
    }

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {
        accounts: [
            getAccountMeta(accounts.globalAdmin),
            getAccountMeta(accounts.authority),
        ],
        programAddress,
        data: getUpdateAdminInstructionDataEncoder().encode({}),
    } as UpdateAdminInstruction<
        TProgramAddress,
        TAccountGlobalAdmin,
        TAccountAuthority
    >;

    return instruction;
}

export type UpdateAdminInput<
    TAccountGlobalAdmin extends string = string,
    TAccountAuthority extends string = string,
> = {
    /** The program derived address of the global admin account to update (seeds: ['global_admin']) */
    globalAdmin: Address<TAccountGlobalAdmin>;
    /** The authority of the global admin */
    authority: TransactionSigner<TAccountAuthority>;
};

export function getUpdateAdminInstruction<
    TAccountGlobalAdmin extends string,
    TAccountAuthority extends string,
    TProgramAddress extends Address = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
>(
    input: UpdateAdminInput<TAccountGlobalAdmin, TAccountAuthority>,
    config?: { programAddress?: TProgramAddress }
): UpdateAdminInstruction<
    TProgramAddress,
    TAccountGlobalAdmin,
    TAccountAuthority
> {
    // Program address.
    const programAddress =
        config?.programAddress ?? TESTUDO_BONDS_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        globalAdmin: { value: input.globalAdmin ?? null, isWritable: true },
        authority: { value: input.authority ?? null, isWritable: false },
    };
    const accounts = originalAccounts as Record<
        keyof typeof originalAccounts,
        ResolvedAccount
    >;

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {
        accounts: [
            getAccountMeta(accounts.globalAdmin),
            getAccountMeta(accounts.authority),
        ],
        programAddress,
        data: getUpdateAdminInstructionDataEncoder().encode({}),
    } as UpdateAdminInstruction<
        TProgramAddress,
        TAccountGlobalAdmin,
        TAccountAuthority
    >;

    return instruction;
}

export type ParsedUpdateAdminInstruction<
    TProgram extends string = typeof TESTUDO_BONDS_PROGRAM_ADDRESS,
    TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
    programAddress: Address<TProgram>;
    accounts: {
        /** The program derived address of the global admin account to update (seeds: ['global_admin']) */
        globalAdmin: TAccountMetas[0];
        /** The authority of the global admin */
        authority: TAccountMetas[1];
    };
    data: UpdateAdminInstructionData;
};

export function parseUpdateAdminInstruction<
    TProgram extends string,
    TAccountMetas extends readonly IAccountMeta[],
>(
    instruction: IInstruction<TProgram> &
        IInstructionWithAccounts<TAccountMetas> &
        IInstructionWithData<Uint8Array>
): ParsedUpdateAdminInstruction<TProgram, TAccountMetas> {
    if (instruction.accounts.length < 2) {
        // TODO: Coded error.
        throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = instruction.accounts![accountIndex]!;
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            globalAdmin: getNextAccount(),
            authority: getNextAccount(),
        },
        data: getUpdateAdminInstructionDataDecoder().decode(instruction.data),
    };
}
